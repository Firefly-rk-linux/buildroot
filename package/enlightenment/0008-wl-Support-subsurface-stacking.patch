From 2be954ad6a3203b6ee71d69b674bdbf71caf8a29 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Fri, 22 Jul 2022 14:55:41 +0800
Subject: [PATCH 08/10] wl: Support subsurface stacking

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 src/bin/e_comp_wl.c | 33 +++++++++++++++++++++++----------
 src/bin/e_comp_wl.h |  2 +-
 2 files changed, 24 insertions(+), 11 deletions(-)

diff --git a/src/bin/e_comp_wl.c b/src/bin/e_comp_wl.c
index db8806c3b..a7d584041 100644
--- a/src/bin/e_comp_wl.c
+++ b/src/bin/e_comp_wl.c
@@ -735,17 +735,29 @@ _e_comp_wl_evas_cb_restack(void *data, Evas *e EINA_UNUSED, Evas_Object *obj EIN
      e_client_transients_restack(ec);
 
    if (!ec->comp_data->sub.list) return;
+   if (eina_list_last(ec->comp_data->sub.list) == ec->comp_data->sub.list) return;
+   if (ec->comp_data->sub.restacking == EINA_TRUE) return;
+
+   ec->comp_data->sub.restacking = EINA_TRUE;
+
    EINA_LIST_FOREACH(ec->comp_data->sub.list, l, sec)
-     evas_object_layer_set(sec->frame, evas_object_layer_get(ec->frame));
+     {
+        if (sec != ec)
+          evas_object_layer_set(sec->frame, evas_object_layer_get(ec->frame));
+     }
+
    sec = eina_list_last_data_get(ec->comp_data->sub.list);
-   evas_object_stack_above(sec->frame, ec->frame);
    EINA_LIST_REVERSE_FOREACH_SAFE(ec->comp_data->sub.list, l, ll, sec)
      {
         E_Client *nsec = eina_list_data_get(ll);
 
-        if (nsec)
+        if (nsec) {
           evas_object_stack_below(nsec->frame, sec->frame);
+          sec = nsec;
+        }
      }
+
+   ec->comp_data->sub.restacking = EINA_FALSE;
 }
 
 static void
@@ -758,7 +770,7 @@ _e_comp_wl_evas_cb_move(void *data, Evas *e EINA_UNUSED, Evas_Object *obj EINA_U
    ec->comp_data->moved = 1;
    EINA_LIST_FOREACH(ec->comp_data->sub.list, l, sec)
      {
-        if (!sec->comp_data->sub.data->position.set)
+        if (ec != sec && !sec->comp_data->sub.data->position.set)
           evas_object_move(sec->frame, ec->client.x + sec->comp_data->sub.data->position.x,
                            ec->client.y + sec->comp_data->sub.data->position.y);
      }
@@ -2310,7 +2322,7 @@ _e_comp_wl_subsurface_cb_place_above(struct wl_client *client EINA_UNUSED, struc
    /* try to get the client from the sibling resource */
    if (!(ecs = wl_resource_get_user_data(sibling_resource))) return;
 
-   if (!ecs->comp_data->sub.data) return;
+   if (!ec->comp_data->sub.data) return;
 
    if (!(parent = ec->comp_data->sub.data->parent)) return;
 
@@ -2320,7 +2332,7 @@ _e_comp_wl_subsurface_cb_place_above(struct wl_client *client EINA_UNUSED, struc
    parent->comp_data->sub.list =
      eina_list_append_relative(parent->comp_data->sub.list, ec, ecs);
 
-   parent->comp_data->sub.restack_target = parent;
+   _e_comp_wl_evas_cb_restack(parent, NULL, NULL, NULL);
 }
 
 static void
@@ -2338,8 +2350,7 @@ _e_comp_wl_subsurface_cb_place_below(struct wl_client *client EINA_UNUSED, struc
 
    /* try to get the client from the sibling resource */
    if (!(ecs = wl_resource_get_user_data(sibling_resource))) return;
-
-   if (!ecs->comp_data->sub.data) return;
+   if (!ec->comp_data->sub.data) return;
 
    if (!(parent = ec->comp_data->sub.data->parent)) return;
 
@@ -2349,7 +2360,7 @@ _e_comp_wl_subsurface_cb_place_below(struct wl_client *client EINA_UNUSED, struc
    parent->comp_data->sub.list =
      eina_list_prepend_relative(parent->comp_data->sub.list, ec, ecs);
 
-   parent->comp_data->sub.restack_target = parent;
+   _e_comp_wl_evas_cb_restack(parent, NULL, NULL, NULL);
 }
 
 static void
@@ -2558,6 +2569,8 @@ _e_comp_wl_client_cb_new(void *data EINA_UNUSED, E_Client *ec)
         return;
      }
 
+   ec->comp_data->sub.list = eina_list_append(ec->comp_data->sub.list, ec);
+
    wl_signal_init(&ec->comp_data->destroy_signal);
    _e_comp_wl_surface_state_init(&ec->comp_data->pending);
 
@@ -2609,7 +2622,7 @@ _e_comp_wl_client_cb_del(void *data EINA_UNUSED, E_Client *ec)
    /* remove sub list */
    EINA_LIST_FREE(ec->comp_data->sub.list, subc)
      {
-        if (!e_object_is_del(E_OBJECT(subc)))
+        if (ec != subc && !e_object_is_del(E_OBJECT(subc)))
           subc->comp_data->sub.data->parent = NULL;
      }
 
diff --git a/src/bin/e_comp_wl.h b/src/bin/e_comp_wl.h
index 8f844dd58..0d1163bfa 100644
--- a/src/bin/e_comp_wl.h
+++ b/src/bin/e_comp_wl.h
@@ -294,7 +294,7 @@ struct _E_Comp_Wl_Client_Data
    struct
      {
         E_Comp_Wl_Subsurf_Data *data;
-        E_Client *restack_target;
+        Eina_Bool restacking;
         Eina_List *list;
      } sub;
 
-- 
2.20.1

